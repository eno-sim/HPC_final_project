#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <time.h>
#include <string.h>
#include <getopt.h>
//Implement utility functions:
//You'll need to implement utility functions such as init_playground,
// load_playground, save_playground,
// update_cell, ordered_evolution, and static_evolution.
 



#define XWIDTH 256
#define YWIDTH 256
#define MAXVAL 255


#if ((0x100 & 0xf) == 0x0)
#define I_M_LITTLE_ENDIAN 1
#define swap(mem) (( (mem) & (short int)0xff00) >> 8) +	\
  ( ((mem) & (short int)0x00ff) << 8)
#else
#define I_M_LITTLE_ENDIAN 0
#define swap(mem) (mem)
#endif

void write_pgm_image( void *image, int maxval, int xsize, int ysize, const char *image_name)
/*
 * image        : a pointer to the memory region that contains the image
 * maxval       : either 255 or 65536
 * xsize, ysize : x and y dimensions of the image
 * image_name   : the name of the file to be written
 *
 */
{
  FILE* image_file; 
  image_file = fopen(image_name, "w"); 
  
  // Writing header
  // The header's format is as follows, all in ASCII.
  // "whitespace" is either a blank or a TAB or a CF or a LF
  // - The Magic Number (see below the magic numbers)
  // - the image's width
  // - the height
  // - a white space
  // - the image's height
  // - a whitespace
  // - the maximum color value, which must be between 0 and 65535
  //
  // if he maximum color value is in the range [0-255], then
  // a pixel will be expressed by a single byte; if the maximum is
  // larger than 255, then 2 bytes will be needed for each pixel
  //

  int color_depth = 1 + ( maxval > 255 );

  fprintf(image_file, "P5\n# generated by\n# put here your name\n%d %d\n%d\n", xsize, ysize, maxval);
  
  // Writing file
  fwrite( image, 1, xsize*ysize*color_depth, image_file);  

  fclose(image_file); 
  return ;

}


void read_pgm_image( void **image, int *maxval, int *xsize, int *ysize, const char *image_name)
/*
 * image        : a pointer to the pointer that will contain the image
 * maxval       : a pointer to the int that will store the maximum intensity in the image
 * xsize, ysize : pointers to the x and y sizes
 * image_name   : the name of the file to be read
 *
 */
{
  FILE* image_file; 
  image_file = fopen(image_name, "r"); 

  *image = NULL;
  *xsize = *ysize = *maxval = 0;
  
  char    MagicN[2];
  char   *line = NULL;
  size_t  k, n = 0;
  
  // get the Magic Number
  k = fscanf(image_file, "%2s%*c", MagicN );

  // skip all the comments
  k = getline( &line, &n, image_file);
  while ( (k > 0) && (line[0]=='#') )
    k = getline( &line, &n, image_file);

  if (k > 0)
    {
      k = sscanf(line, "%d%*c%d%*c%d%*c", xsize, ysize, maxval);
      if ( k < 3 )
	      fscanf(image_file, "%d%*c", maxval);
    }
  else
    {
      *maxval = -1;         // this is the signal that there was an I/O error
			    // while reading the image header
      free( line );
      return;
    }
  free( line );
  
  int color_depth = 1 + ( *maxval > 255 );
  unsigned int size = *xsize * *ysize * color_depth;
  
  if ( (*image = (char*)malloc( size )) == NULL )
    {
      fclose(image_file);
      *maxval = -2;         // this is the signal that memory was insufficient
      *xsize  = 0;
      *ysize  = 0;
      return;
    }
  
  if ( fread( *image, 1, size, image_file) != size )
    {
      free( image );
      image   = NULL;
      *maxval = -3;         // this is the signal that there was an i/o error
      *xsize  = 0;
      *ysize  = 0;
    }  

  fclose(image_file);
  return;
}


void swap_image( void *image, int xsize, int ysize, int maxval )
/*
 * This routine swaps the endianism of the memory area pointed
 * to by ptr, by blocks of 2 bytes
 *
 */
{
  if ( maxval > 255 )
    {
      // pgm files has the short int written in
      // big endian;
      // here we swap the content of the image from
      // one to another
      //
      unsigned int size = xsize * ysize;
      for ( int i = 0; i < size; i++ )
  	((unsigned short int*)image)[i] = swap(((unsigned short int*)image)[i]);
    }
  return;
}


void * init_playground(int xsize, int ysize)
{
    srand(time(NULL));

    // Allocate memory for the image
    unsigned char *image = (unsigned char *)malloc(xsize * ysize * sizeof(unsigned char));

    // Generate random black-and-white pixel values
    for (int y = 0; y < ysize; y++)
    {
        for (int x = 0; x < xsize; x++)
        {
            image[y * xsize + x] = (rand() % 2) * MAXVAL;
        }
    }

    // Return the pointer to the allocated memory
    return (void *)image;
}





void update_ordered_cell(unsigned char *playground, int xsize, int ysize, int x, int y)
{
    int alive_neighbors = 0;
    for (int i = -1; i <= 1; i++)
    {
        for (int j = -1; j <= 1; j++)
        {
            if (i == 0 && j == 0)
                continue;

            int nx = (x + i + xsize) % xsize;
            int ny = (y + j + ysize) % ysize;
            alive_neighbors += (playground[ny * xsize + nx]==MAXVAL);
        }
    }

    int cell_index = y * xsize + x;
    playground[cell_index] = ( ((((playground[cell_index]==255) && (alive_neighbors == 2 || alive_neighbors == 3))) || ((playground[cell_index]==0) && alive_neighbors == 3))  ? 255 : 0);
}

void ordered_evolution(unsigned char *playground, int xsize, int ysize, int n)
{
  
  
    for (int step = 0; step < n; step++)
    {
        for (int y = 0; y < ysize; y++)
        {
            for (int x = 0; x < xsize; x++)
            {
                update_ordered_cell(playground, xsize, ysize, x, y);
            }
        }
    }
}


void update_cell_static(const unsigned char *old_playground, unsigned char *new_playground, int xsize, int ysize, int x, int y)
{
    int alive_neighbors = 0;
    for (int i = -1; i <= 1; i++)
    {
        for (int j = -1; j <= 1; j++)
        {
            if (i == 0 && j == 0){
                continue;
            }
            int nx = (x + i + xsize) % xsize;
            int ny = (y + j + ysize) % ysize;
            alive_neighbors += (old_playground[ny * xsize + nx]==MAXVAL);
        }
    }

    int cell_index = y * xsize + x;
    new_playground[cell_index] = ( ((((old_playground[cell_index]==255) && (alive_neighbors == 2 || alive_neighbors == 3))) || 
    ((old_playground[cell_index]==0) && alive_neighbors == 3))  ? 255 : 0);
}

void static_evolution(unsigned char *playground, int xsize, int ysize, int n)
{
    unsigned char *new_playground = (unsigned char *)malloc(xsize * ysize * sizeof(unsigned char));

    for (int step = 0; step < n; step++)
    {
        for (int y = 0; y < ysize; y++)
        {
            for (int x = 0; x < xsize; x++)
            {
                update_cell_static(playground, new_playground, xsize, ysize, x, y);
            }
        }

        memcpy(playground, new_playground, xsize * ysize * sizeof(unsigned char));
    }

    free(new_playground);
}








#define INIT 1
#define RUN  2

#define K_DFLT 100

#define ORDERED 0
#define STATIC  1


// char fname_deflt[] = "game_of_life.pgm";

int   action = 0;
int   k      = K_DFLT;  //size of the squared  playground
int   e      = ORDERED; //evolution type [0\1]
int   n      = 10000;  // number of iterations 
int   s      = 1;      // every how many steps a dump of the system is saved on a file
                      // 0 meaning only at the end.
char *fname  = NULL;  // name of the file to be either read or written


int main ( int argc, char **argv )
{
  /*Each character in the optstring represents a single-character
    option that the program accepts. If a character is followed by a colon (:),
    it indicates that the option requires an argument.
     -i: No argument required. Initialize playground.
     -r: No argument required. Run a playground.
     -k: Requires an argument (e.g., -k 100). Playground size.
     -e: Requires an argument (e.g., -e 1). Evolution type.
     -f: Requires an argument (e.g., -f filename.pgm). 
     Name of the file to be either read or written
     -n: Requires an argument (e.g., -n 10000). Number of steps.
     -s: Requires an argument (e.g., -s 1). Frequency of dump.*/
  char *optstring = "irk:e:f:n:s:";
  int maxval = 255;
  int c;
  /*When the getopt function is called in the while loop,
    it processes the command-line arguments according to
    the format specified in optstring.
    The getopt function returns the next option character or -1 if there are no more options
 */
  while ((c = getopt(argc, argv, optstring)) != -1) {
    switch(c) {
      
    case 'i':
      action = INIT; 

      
      break;
      
    case 'r':
      action = RUN; break;
      
    case 'k':
      k = atoi(optarg); break;

    case 'e':
      e = atoi(optarg); break;

    case 'f':
      fname = (char*)malloc( sizeof(optarg)+1 );
      sprintf(fname, "%s", optarg );
      break;  

    case 'n':
      n = atoi(optarg); break;

    case 's':
      s = atoi(optarg); break;

    default :
      printf("argument -%c not known\n", c ); break;
    }
  }

  if(action==INIT){
    void * ptr = init_playground(k, k);
    write_pgm_image(ptr, 255, k, k, fname);
    free(ptr);
  }

  if (action==RUN)
  {
    if(e == ORDERED){
       unsigned char *playground_o = (unsigned char *)malloc(k * k * sizeof(unsigned char));
       read_pgm_image((void **)&playground_o, &maxval, &k, &k, fname);
       ordered_evolution(playground_o, k, k, n);
       write_pgm_image((void *)playground_o, 255, k, k, "test_dump_ordered.pgm");
       free(playground_o);

    }
    else if(e == STATIC){
      unsigned char * playground_s = (unsigned char *)malloc(k*k*sizeof(unsigned char));
       read_pgm_image((void **)&playground_s, &maxval, &k, &k, fname);
       static_evolution(playground_s, k, k, n);
       write_pgm_image((void *)playground_s, 255, k, k, "test_dump_static.pgm");
       free(playground_s);

    }
    else {
      printf("Error!");
    }
  }
  

  if ( fname != NULL )
    free ( fname );
    
  return 0;
}




